# kernel

Interfaces used in kernel mode require the fridamod framework. Use `runtime.isKernel` to determine if you are in kernel mode.

In kernel mode, the target application is not injected. Instead, a side-process is cloned where Frida is executed. Only the APIs provided by jshook can be used in the script, and hook-related APIs are invalid.

## kernel.getModuleBase(libname)

Get the memory address of a certain so shared library, which can be used for memory offset calculation.

**Parameters**:

- `libname`: string

**Returns**: string

## kernel.readDword(address)

Get the integer value at the memory address.

**Parameters**:

- `address`: string

**Returns**: long

## kernel.readFloat(address)

Get the floating-point value at the memory address.

**Parameters**:

- `address`: string

**Returns**: float

## kernel.writeDword(address, value)

Write an integer value to the memory address.

**Parameters**:

- `address`: string
- `value`: long

**Returns**: int

## kernel.writeFloat(address, value)

Write a floating-point value to the memory address.

**Parameters**:

- `address`: string
- `value`: float

**Returns**: int

## Example Script

First, download the target application for practice [https://github.com/JsHookApp/Download/releases/download/files/Learn.Frida.apk](https://github.com/JsHookApp/Download/releases/download/files/Learn.Frida.apk)

And the corresponding `dump.cs` file [https://github.com/JsHookApp/Download/releases/download/files/Learn.Frida_dump.cs](https://github.com/JsHookApp/Download/releases/download/files/Learn.Frida_dump.cs)

The `Learn.Frida_dump.cs` file mainly analyzes `public class FieldTest : MonoBehaviour` and its methods.

Below is the script example. The script first finds the memory base address using Frida in non-kernel mode. Of course, you can find the memory base address by other means, and then modify the variable value in kernel mode. Clicking the `ShowResult` button will display an input box used to input the current value of `staticA` to search for the memory address.

```javascript
// Memory scan
const memoryScan = (m, pattern, call) => {
    Memory.scan(m.base, m.size, pattern, {
        onMatch(address, size) {
            call(address)
            return 'stop';
        },
        onComplete() {}
    });
};

function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

// Start using kernel
if (runtime.isKernel) {

    console.log('kernel start');

    const time = setInterval(() => {
        const il2cpp = kernel.getModuleBase('libil2cpp.so');
        if (il2cpp) {
            clearInterval(time);
            console.log('il2cpp', il2cpp);

            // Read/Modify data
            setInterval(() => {
                const newval = getRandomInt(100, 999);
                console.log('newval', newval);
                kernel.writeDword('0x7e3fe30c30', newval);

                const kernel_staticA = kernel.readDword('0x7e3fe30c30');
                console.log('staticA', kernel_staticA);
            }, 3000);
        }
    }, 100);
} else {

    // In non-kernel mode, use Frida to find the memory base address of the variable. You can also use other methods to get it.

    const time = setInterval(() => {
        const addr = Module.findBaseAddress('libil2cpp.so');
        if (addr) {
            clearInterval(time);
            console.log('libil2cpp ok');
            // The il2cpp module address is dynamic
            const il2cpp = ptr(addr);
            console.log('il2cpp', il2cpp);
            // This 0x667F14 is an offset, fixed, pointing to the ShowResult method
            Interceptor.attach(il2cpp.add(0x667F14), {
                onEnter: function (args) {
                    // Current instance
                    const instance = args[0];

                    // Input the current value of staticA to search memory
                    dialog.input('search_val', {
                        ok: function (res) {

                            // Get search range
                            const range = Process.findRangeByAddress(instance);

                            // Search condition
                            const pattern = ptr(parseInt(res)).toMatchPattern().replace(' 00 00 00 00', '');

                            memoryScan(range, pattern, (address) => {
                                // Variable memory address
                                console.log('staticA_address', address);

                                // Variable memory value
                                const staticA = ptr(address).readInt();
                                console.log('staticA', staticA);

                                // Modify
                                ptr(address).writeInt(1000);
                            });
                        },
                        cancel: function () {}
                    }, '');
                },
                onLeave: function (retval) {}
            });
        }
    }, 100);
}
```