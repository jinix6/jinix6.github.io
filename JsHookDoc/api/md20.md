# memory

Used for direct memory access in kernel mode. Requires support from the `fridamod` framework.

## memory.getModuleBase(libname)

Get the memory address of a shared library (SO).

**Parameters**:

`libname`: string - Name of the shared library.

**Returns**: string - Memory address.

## memory.readDword(address)

Read an integer value from a memory address.

**Parameters**:

`address`: string - Memory address.

**Returns**: long - Integer value.

## memory.readFloat(address)

Read a float value from a memory address.

**Parameters**:

`address`: string - Memory address.

**Returns**: float - Float value.

## memory.writeDword(address,value)

Write an integer value to a memory address.

**Parameters**:

`address`: string - Memory address.

`value`: long - Integer value to write.

**Returns**: int

## memory.writeFloat(address,value)

Write a float value to a memory address.

**Parameters**:

`address`: string - Memory address.

`value`: float - Float value to write.

**Returns**: int

## Sample Script

First, download the target application for practice: [Learn.Frida.apk](https://github.com/JsHookApp/Download/releases/download/files/Learn.Frida.apk)

Also download the corresponding `dump.cs` file: [Learn.Frida_dump.cs](https://github.com/JsHookApp/Download/releases/download/files/Learn.Frida_dump.cs)

The `Learn.Frida_dump.cs` file mainly analyzes the methods in `public class FieldTest : MonoBehaviour`.

Here's a script example: Initially, use Frida in non-kernel mode to find the memory base address. You can use other methods to find the memory base address. Click the `ShowResult` button to display an input box for entering the current `staticA` value to search for the memory address.

```javascript
// Memory scan
const memoryScan = (m, pattern, call) => {
    Memory.scan(m.base, m.size, pattern, {
        onMatch(address, size) {
            call(address)
            return 'stop';
        },
        onComplete() {
        }
    });
}

function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

// Start using kernel mode
if (runtime.isKernel) {

    console.log('kernel start')

    const time = setInterval(() => {
        const il2cpp = memory.getModuleBase('libil2cpp.so')
        if (il2cpp) {
            clearInterval(time)
            console.log('il2cpp', il2cpp)

            // Read/modify data
            setInterval(() => {
                const newval = getRandomInt(100, 999)
                console.log('newval', newval)
                memory.writeDword('0x7e3fe30c30', newval)

                const memory_staticA = memory.readDword('0x7e3fe30c30')
                console.log('staticA', memory_staticA)
            }, 3000)
        }
    }, 100)
} else {

    // In non-kernel mode, use Frida to find the memory base address of variables. You can also use other methods to obtain it.

    const time = setInterval(() => {
        const addr = Module.findBaseAddress('libil2cpp.so')
        if (addr) {
            clearInterval(time)
            console.log('libil2cpp ok')
            // il2cpp module address is dynamic
            const il2cpp = ptr(addr)
            console.log('il2cpp', il2cpp)
            // This 0x667F14 is an offset, fixed, pointing to the ShowResult method
            Interceptor.attach(il2cpp.add(0x667F14), {
                onEnter: function (args) {
                    // Current instance
                    const instance = args[0]

                    // Input the current staticA value to search for memory
                    dialog.input('search_val', {
                        ok: function (res) {

                            // Get search range
                            const range = Process.findRangeByAddress(instance)

                            // Search criteria
                            const pattern = ptr(parseInt(res)).toMatchPattern().replace(' 00 00 00 00', '')

                            memoryScan(range, pattern, (address) => {
                                // Variable memory address
                                console.log('staticA_address', address)

                                Java.perform(function () {
                                    // Variable memory value, read using memory interface
                                    const staticA = memory.readDword(String(address))
                                    console.log('staticA', staticA)

                                    // Modify using memory interface
                                    memory.writeDword(String(address), 1000)
                                })
                            })
                        },
                        cancel: function () {
                        }
                    }, '')
                },
                onLeave: function (retval) {
                }
            })
        }
    }, 100)

}
```